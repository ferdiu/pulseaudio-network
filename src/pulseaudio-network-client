#!/usr/bin/env python3
"""
PulseAudio Network Client
Manages PulseAudio tunnel sink with configuration file support
"""

import json
import logging
import os
import signal
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, Optional

class PulseAudioClient:
    def __init__(self, config_dir: str = "/etc/pulseaudio-network"):
        self.config_dir = Path(config_dir)
        self.config_file = self.config_dir / "client.json"
        self.module_ids = []
        self.running = True

        # Set up logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler('/var/log/pulseaudio-client.log')
            ]
        )
        self.logger = logging.getLogger(__name__)

        # Handle signals for graceful shutdown
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

    def _signal_handler(self, signum: int, frame) -> None:
        """Handle termination signals"""
        self.logger.info(f"Received signal {signum}, initiating graceful shutdown")
        self.running = False

    def load_config(self) -> Dict:
        """Load configuration from JSON file"""
        default_config = {
            "servers": [
                {
                    "host": "192.168.1.100",
                    "port": 4656,
                    "sink_name": "network_sink",
                    "sink_description": "Network Audio Sink"
                }
            ],
            "auto_connect": True,
            "retry_interval": 10,
            "max_retries": -1
        }

        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    # Merge with defaults, but keep servers if provided
                    if 'servers' not in config:
                        config['servers'] = default_config['servers']
                    for key, value in default_config.items():
                        if key not in config:
                            config[key] = value
                    self.logger.info(f"Loaded configuration from {self.config_file}")
            else:
                config = default_config
                self.logger.warning(f"Config file {self.config_file} not found, using defaults")
                # Create default config file
                self.config_dir.mkdir(parents=True, exist_ok=True)
                with open(self.config_file, 'w') as f:
                    json.dump(default_config, f, indent=2)
                self.logger.info(f"Created default config at {self.config_file}")

        except (json.JSONDecodeError, IOError) as e:
            self.logger.error(f"Error loading config: {e}, using defaults")
            config = default_config

        return config

    def check_pulseaudio(self) -> bool:
        """Check if PulseAudio is running and accessible"""
        try:
            result = subprocess.run(
                ['pactl', 'info'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                self.logger.debug("PulseAudio is accessible")
                return True
            else:
                self.logger.error("PulseAudio is not accessible")
                return False
        except subprocess.SubprocessError as e:
            self.logger.error(f"Error checking PulseAudio: {e}")
            return False

    def test_server_connection(self, host: str, port: int) -> bool:
        """Test if the PulseAudio server is reachable"""
        import socket
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception as e:
            self.logger.debug(f"Connection test failed for {host}:{port}: {e}")
            return False

    def load_tunnel_sink(self, server_config: Dict) -> Optional[str]:
        """Load a tunnel sink for a specific server"""
        host = server_config['host']
        port = server_config['port']
        sink_name = server_config.get('sink_name', f"tunnel_sink_{host}_{port}")
        sink_description = server_config.get('sink_description', f"Tunnel to {host}:{port}")

        # Test server connectivity first
        if not self.test_server_connection(host, port):
            self.logger.warning(f"Server {host}:{port} is not reachable")
            return None

        args = [
            f"server=tcp:{host}:{port}",
            f"sink_name={sink_name}",
            f"sink_properties=device.description='{sink_description}'"
        ]

        cmd = ['pactl', 'load-module', 'module-tunnel-sink'] + args

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=15
            )

            if result.returncode == 0:
                module_id = result.stdout.strip()
                self.logger.info(f"Loaded tunnel sink '{sink_name}' to {host}:{port} (module ID: {module_id})")
                return module_id
            else:
                self.logger.error(f"Failed to load tunnel sink to {host}:{port}: {result.stderr}")
                return None

        except subprocess.SubprocessError as e:
            self.logger.error(f"Error loading tunnel sink: {e}")
            return None

    def unload_module(self, module_id: str) -> bool:
        """Unload a PulseAudio module"""
        try:
            result = subprocess.run(
                ['pactl', 'unload-module', module_id],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                self.logger.info(f"Unloaded module {module_id}")
                return True
            else:
                self.logger.error(f"Failed to unload module {module_id}: {result.stderr}")
                return False

        except subprocess.SubprocessError as e:
            self.logger.error(f"Error unloading module {module_id}: {e}")
            return False

    def unload_all_modules(self) -> None:
        """Unload all loaded modules"""
        for module_id in self.module_ids.copy():
            if self.unload_module(module_id):
                self.module_ids.remove(module_id)

    def run(self) -> int:
        """Main run loop"""
        self.logger.info("Starting PulseAudio Network Client")

        # Wait for PulseAudio to be available
        max_retries = 30
        for retry in range(max_retries):
            if self.check_pulseaudio():
                break
            if not self.running:
                return 1
            self.logger.info(f"Waiting for PulseAudio... ({retry + 1}/{max_retries})")
            time.sleep(1)
        else:
            self.logger.error("PulseAudio not available after 30 seconds")
            return 1

        # Load configuration
        config = self.load_config()
        retry_count = 0
        max_retries = config.get('max_retries', -1)
        retry_interval = config.get('retry_interval', 10)

        # Main loop
        try:
            while self.running:
                # Try to connect to all configured servers
                connected_any = False

                for server_config in config['servers']:
                    host = server_config['host']
                    port = server_config['port']

                    # Check if we already have a connection to this server
                    sink_name = server_config.get('sink_name', f"tunnel_sink_{host}_{port}")
                    already_connected = False

                    # Check if sink already exists
                    try:
                        result = subprocess.run(
                            ['pactl', 'list', 'sinks', 'short'],
                            capture_output=True,
                            text=True,
                            timeout=5
                        )
                        if result.returncode == 0 and sink_name in result.stdout:
                            already_connected = True
                            connected_any = True
                    except Exception:
                        pass

                    if not already_connected:
                        module_id = self.load_tunnel_sink(server_config)
                        if module_id:
                            self.module_ids.append(module_id)
                            connected_any = True
                            retry_count = 0  # Reset retry count on successful connection

                if connected_any:
                    self.logger.info("Client started successfully, entering main loop")

                    # Main monitoring loop
                    while self.running:
                        time.sleep(retry_interval)

                        # Check if PulseAudio is still running
                        if not self.check_pulseaudio():
                            self.logger.error("PulseAudio is no longer accessible")
                            break

                        # TODO: Could add periodic health checks for tunnel sinks here

                    break
                else:
                    # No connections established
                    retry_count += 1
                    if max_retries > 0 and retry_count >= max_retries:
                        self.logger.error(f"Max retries ({max_retries}) reached, giving up")
                        return 1

                    self.logger.warning(f"No servers available, retrying in {retry_interval}s... (attempt {retry_count})")
                    time.sleep(retry_interval)

        except KeyboardInterrupt:
            self.logger.info("Received keyboard interrupt")
        finally:
            self.logger.info("Shutting down client")
            self.unload_all_modules()

        return 0

def main():
    # Check if running as user service
    config_dir = os.path.expanduser("~/.config/pulseaudio-network")
    if os.getenv("XDG_CONFIG_HOME"):
        config_dir = os.path.join(os.getenv("XDG_CONFIG_HOME"), "pulseaudio-network")

    client = PulseAudioClient(config_dir)
    return client.run()

if __name__ == "__main__":
    sys.exit(main())